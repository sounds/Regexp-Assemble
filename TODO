1. Tree equivalencies. Currently, /contend/ /content/ /resend/ /resent/
produces (?:conten[dt]|resend[dt]) but it is possible to produce
(?:cont|res)en[dt] if one can spot the common tail nodes (and walk back
the equivalent paths). Or be by me my => /[bm][ey]/ in the simplest case.

To do this requires a certain amount of restructuring of the code.
Currently, the algorithm uses a two-phase approach. In the first
phase, the trie is traversed and reductions are performed. In the
second phase, the reduced trie is traversed and the pattern is
emitted.

What has to occur is that the reduction and emission have to occur
together. As a node is completed, it is replaced by its string
representation. This then allows child nodes to be compared for
equality with a simple 'eq'. Since there is only a single traversal,
the overall generation time might drop, even though the context
baggage required to delve through the tree will be more expensive
to carry along (a hash rather than a couple of scalars).

2. Investigate how (?>foo) works. Can it be applied?

5. How can a tracked pattern be serialised? (Add freeze and thaw methods).

6. Store callbacks per tracked pattern.

7. Deal with [:punct:] et al character classes

12. utf-8... hmmmm...

14. Adding qr//'ed patterns. For example, consider
    $r->add ( qr/^abc/i )
        ->add( qr/^abd/ )
        ->add( qr/^ab e/x );
    this should admit abc abC aBc aBC abd abe as matches

15. Methods to specify adding ^, $, \b, \A, \Z to resulting pattern,
    and/or any arbitrary prefix/suffix. The method names would be
    anchor_word => \b
    anchor_line => ^, $
    anchor_string => \A, \Z
    and
    anchor_(mumble)_begin to get just one.

    Subquestion: how to deal with \Z or \z

16. Allow a fast, unsafe tracking mode, that can be used if a(?bc)?
    can't happen. (Possibly carp if it does appear during traversal)?

17. given a-\d+-\d+-\d+-\d+-b, produce a(?:-\d+){4}-b. Something
    along the lines of (.{4))(\1+) would let the regexp engine
    itself be brought to bear on the matter, which is a rather
    appealing idea.

18. The attribute handling in new() and clone() is getting very silly.

19. The reduction code has become unbelievably baroque. Adding code
    to handle (sting,singing,sing) => s(?:(?:ing)?|t)ing was far
    too difficult. Adding more stuff just breaks existing behaviour.
    And fixing the ^abcd$ ... bug broke stuff all over again.
    Now that the corner cases are more clearly identified, a full
    rewrite of the reduction code is needed. And would admit the
    possibility of implementing items 1 and 17.

20. Handle debug unrev with a separate bit

21. Now that lex() has a non-backslash shortcut, lex() could probably
    be subsumed into lex_stateful. That is, only stateful.

22. Add a file() method or something similar, to do file-slurping
    of patterns to add (to cut down on make-work code in client code.

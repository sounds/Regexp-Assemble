1. Tree equivalencies. Currently, /contend/ /content/ /resend/ /resent/
produces (?:conten[dt]|resend[dt]) but it is possible to produce
(?:cont|res)en[dt] if one can spot the common tail nodes (and walk back
the equivalent paths).

2. Investigate how (?>foo) works. Can it be applied?

3. Deal with \Q ... \E

4. Factor out slide procedure.

5. How can a tracked pattern be serialised? (Add freeze and thaw methods).

6. Store callbacks per tracked pattern.

7. Deal with [:punct:] character classes

8. saw this foo(?:\.|-)bar but the test checks out ok

9. use eq_or_diff, or fall back on is_deeply

10. Add indent() as a first-class method

11. update eg/naive, is eg/assemble-check obsolete?

12. utf-8... hmmmm...

13. Consider the following:
        % eg/assemble -d2
        sing
        singing
        sting
        path 0 in [s {i=>[i n g {* i=>[i n g]}] t=>[t i n g]}]
         node 1 in {i=>[i n g {* i=>[i n g]}] t=>[t i n g]} opt=0
          | off=-1
          | path=(g:[n i t])
          | counts: reduce=1 fail=0
          | off=3
           node 3 in {i=>[i n g]} opt=1
           | fast fail {* i=>[i n g]}
          | +failed i
          | counts: reduce=1 fail=1
         : node scan complete opt=0 reduce={g=>[[g n i t]]} fail=[[i n g {* i=>[i n g]}]]
         | -simple opt=0 unrev [g n i t]
          _unrev path fast [g n i t] -> [t i n g]
         | +f=[i n g {* i=>[i n g]}]
         node 1 out fail={i=>[i n g {* i=>[i n g]}] t=>[t i n g]}
        | head=[] tail={i=>[i n g {* i=>[i n g]}] t=>[t i n g]}
        | unshift s
        path 0 out head=[] tail=[s {i=>[i n g {* i=>[i n g]}] t=>[t i n g]}]
        final head=[] tail=[s {i=>[i n g {* i=>[i n g]}] t=>[t i n g]}]
        final path=[s {i=>[i n g {* i=>[i n g]}] t=>[t i n g]}]
        /s(?:ing(?:ing)?|ting)/
        s(?:ing(?:ing)?|ting)
    In other words, there is scope for a further approach to tail-sliding.
        
14. _lex is *really* slow

1. Tree equivalencies. Currently, /contend/ /content/ /resend/ /resent/
produces (?:conten[dt]|resend[dt]) but it is possible to produce
(?:cont|res)en[dt] if one can spot the common tail nodes (and walk back
the equivalent paths).

2. Investigate how (?>foo) works. Can it be applied?

5. How can a tracked pattern be serialised? (Add freeze and thaw methods).

6. Store callbacks per tracked pattern.

7. Deal with [:punct:] character classes

8. saw this foo(?:\.|-)bar but the test checks out ok

11. is eg/assemble-check obsolete?

12. utf-8... hmmmm...

13. Consider the following:

    $ eg/assemble -d2
    sing
    singing
    sting
    path 0 in [s {i=>[i n g {* i=>[i n g]}] t=>[t i n g]}]
     node 1 in {i=>[i n g {* i=>[i n g]}] t=>[t i n g]} opt=0
      | off=-1
      | path=(g:[n i t])
      | counts: reduce=1 fail=0
      | off=3
       node 3 in {i=>[i n g]} opt=1
       | fast fail {* i=>[i n g]}
      | +failed i
      | counts: reduce=1 fail=1
     : node scan complete opt=0 reduce={g=>[[g n i t]]} fail=[[i n g {* i=>[i n g]}]]
     | -simple opt=0 unrev [g n i t]
      _unrev path fast [g n i t] -> [t i n g]
     | +fail [i n g {* i=>[i n g]}]
     node 1 out fail={i=>[i n g {* i=>[i n g]}] t=>[t i n g]}
    | head=[] tail={i=>[i n g {* i=>[i n g]}] t=>[t i n g]}
    | unshift s
    path 0 out head=[] tail=[s {i=>[i n g {* i=>[i n g]}] t=>[t i n g]}]
    final head=[] tail=[s {i=>[i n g {* i=>[i n g]}] t=>[t i n g]}]
    final path=[s {i=>[i n g {* i=>[i n g]}] t=>[t i n g]}]
    /s(?:ing(?:ing)?|ting)/

    In other words, there is scope for a further approach to tail-sliding.
        
